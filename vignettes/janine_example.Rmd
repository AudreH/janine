---
title: "Estimation of Gaussian Graphical Model with blockwise latent Organisation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Estimation of Gaussian Graphical Model with blockwise latent Organisation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Preliminaries

```{r setup, message = FALSE}
library(janine)   
library(rggm)     # GGM data generation
library(corrplot) # fancy graphical output
```

## Generating Gaussian data from a Graphical Model with SBM structure

We use the package `rggm` to draw hopefully realistic Gaussian multivariate data faithful to the graphical model of an underlying stohastic bloc model.


We first define some parameter to draw the SBM:

```{r SBM setting}
nNodes  <- 90
blockProp <- c(1/3, 1/3, 1/3)   # group proportions
nbBlock   <- length(blockProp) # number of blocks
connectParam <- diag(.4, nbBlock) + 0.01 # connectivity matrix: affiliation network
```

The network itself is then sampled:

```{r SBM structure}
mySBM <- rSBM(nNodes, connectParam, blockProp)
```

From this network we build a signed precision matrix 

```{r GGM}
Omega <- graph2prec(mySBM, cond_var = rep(1, nNodes), neg_prop = 0.5)
Sigma <- solve(Omega)
```

We can finally sample some multivariate Gaussian data.

```{r mv data}
n <- 500
means <- rep(0, ncol(Sigma))
X <- rmgaussian(n, means, Sigma)
```

## Network Inference with Janine

`Janine` (a reference to the `Simone` package, from which Janine is a reload/remake), specially targeting GGM inference with underlying blockwise pattern governed by an SBM. The inference alternate adaptive graphical-LASSO and SBM with variational EM. The weigths in the graphical-Lasso are

\begin{equation}
  w_{ij} = \frac{\left(1 - \hat{\mathbb{P}}(i \leftrightarrow j)\right)}{1 - \mathrm{density}(\hat{\mathcal{G}})},
\end{equation}

where $\hat{\mathcal{G}}$ is the current estimate of the network and $\hat{\mathbb{P}}(i \leftrightarrow j)$ is the estimated probability of connection between any dyad under the fitted SBM (that is, conditional on the block of the nodes).

The overall amount of sparsity is tuned by the argument `penalties`, and the number of blocks in the SBM is fixed by argument `n_blocks`. By default, janine is fitted on a vector of penalties automaticcaly generated.

```{r janine}
out <- janine(X, n_blocks = nbBlock,
              control_optim = list(epsilon = 1e-4, max_iter = 20, trace = 1, n_cores = 1),
              control_penalties = list(min_ratio = 0.075, length = 20, diagonal = TRUE))
```

In this setting, the criteria looks good but probably need to be adapted cause they choose a too sparse model

```{r criteria_plot}
plot(out$criteria$penalty, out$criteria$loglik, type = "b", xlab = 'iteration', ylab = 'criteria', log = "x")
lines(out$criteria$penalty, out$criteria$BIC, col = "red")
lines(out$criteria$penalty, out$criteria$EBIC, col = "blue")
legend('topright', bty = "n", c("loglikelihood", "BIC", "EBIC"), col = c("black", "red", "blue"), lty = c(1,1,1))
abline(v = out$criteria$penalty[which.max(out$criteria$EBIC)])
```

The estimation is visually good too if we consider the more dense model, so we need to think a bit more about the model selection issue.

```{r}
model_EBIC  <- out$models[[which.max(out$criteria$EBIC)]]
model_dense <- out$models[[length(out$models)]]
```


```{r plot_estimators}
par(mfrow = c(3,2))
corrplot(as.matrix(Omega), is.corr = FALSE, tl.pos = "n", method = 'color', type = "upper", diag = FALSE, title = "TRUE precision")
corrplot(as.matrix(Sigma), is.corr = FALSE, tl.pos = "n", method = 'color', type = "upper", diag = FALSE, title = "TRUE variance")
corrplot(model_EBIC$net$Omega, is.corr = FALSE, tl.pos = "n", method = 'color', type = "upper", diag = FALSE, title = "Estimated precision")
corrplot(model_EBIC$net$Sigma, is.corr = FALSE, tl.pos = "n", method = 'color', type = "upper", diag = FALSE, title = "Estimated variance")
corrplot(model_dense$net$Omega, is.corr = FALSE, tl.pos = "n", method = 'color', type = "upper", diag = FALSE, title = "Estimated precision")
corrplot(model_dense$net$Sigma, is.corr = FALSE, tl.pos = "n", method = 'color', type = "upper", diag = FALSE, title = "Estimated variance")
```

## TODO
  - Multipartite

