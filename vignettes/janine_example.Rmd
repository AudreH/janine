---
title: "Estimation of Gaussian Graphical Model with blockwise latent Organisation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Estimation of Gaussian Graphical Model with blockwise latent Organisation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Preliminaries

```{r setup, message = FALSE}
library(janine)   
library(rggm)     # GGM data generation
library(corrplot) # fancy graphical output
```

## Generating Gaussian data from a Graphical Model with SBM structure

We use the package `rggm` to draw hopefully realistic Gaussian multivariate data faithful to the graphical model of an underlying stohastic bloc model.


We first define some parameter to draw the SBM:

```{r SBM setting}
nNodes  <- 90
blockProp <- c(1/3, 1/3, 1/3)   # group proportions
nbBlock   <- length(blockProp) # number of blocks
connectParam <- diag(.4, nbBlock) + 0.01 # connectivity matrix: affiliation network
```

The network itself is then sampled:

```{r SBM structure}
mySBM <- rSBM(nNodes, connectParam, blockProp)
```

From this network we build a signed precision matrix 

```{r GGM}
Omega <- graph2prec(mySBM, cond_var = rep(1, nNodes), neg_prop = 0.5)
Sigma <- solve(Omega)
```

We can finally sample some multivariate Gaussian data.

```{r mv data}
n <- 1000
means <- rep(0, ncol(Sigma))
X <- rmgaussian(n, means, Sigma)
```

## Network Inference with Janine

`Janine` (a reference to the `Simone` package, from which Janine is a reload/remake), specially targeting GGM inference with underlying blockwise pattern governed by an SBM. The inference alternate adaptive graphical-LASSO and SBM with variational EM. The weigths in the graphical-Lasso are

\begin{equation}
  w_{ij} = \frac{\left(1 - \hat{\mathbb{P}}(i \leftrightarrow j)\right)}{1 - \mathrm{density}(\hat{\mathcal{G}})},
\end{equation}

where $\hat{\mathcal{G}}$ is the current estimate of the network and $\hat{\mathbb{P}}(i \leftrightarrow j)$ is the estimated probability of connection between any dyad under the fitted SBM (that is, conditional on the block of the nodes).

The overall amount of sparsity is tuned by the argument `penalty`, and the number of blocks in the SBM is fixed by argument `n_blocks`

```{r janine}
out <- janine(X, penalty = 0.075, n_blocks = nbBlock)
```

In this easy data setting, the method seems to work well, exhibiting a nice convergence of the objective function (the penalized negative log-likelihood):

```{r objective plot}
plot(out$objective, type = "b", xlab = 'iteration', ylab = 'objective')
```

The estimation is visually good too

```{r plot estiamtor}
par(mfrow = c(2,2))
corrplot(as.matrix(Omega), is.corr = FALSE, tl.pos = "n", method = 'color', type = "upper", diag = FALSE, title = "TRUE precision")
corrplot(as.matrix(Sigma), is.corr = FALSE, tl.pos = "n", method = 'color', type = "upper", diag = FALSE, title = "TRUE variance")
corrplot(out$net$Omega, is.corr = FALSE, tl.pos = "n", method = 'color', type = "upper", diag = FALSE, title = "Estimated precision")
corrplot(out$net$Sigma, is.corr = FALSE, tl.pos = "n", method = 'color', type = "upper", diag = FALSE, title = "Estimated variance")
```

## TODO

  - EBIC and ICL to choose the number of block and the level of penalty
  - Multipartite

